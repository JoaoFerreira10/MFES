class System

types

public User :: name: seq of char;
public Sector :: name: seq of char;

	groupUser = set of User;
	groupSector = set of Sector;


values
-- TODO Define values here
instance variables
/*
private group_users : seq of Group_User := [];
private group_sectors : seq of Group_Sector := [];
private rules : seq of Rules :=[];
private name : InstitutionName;*/

system: seq of char;

	users: set of User := {};
	
	group_users: map seq of char to groupUser := {|->};
	
	/* facilities as a set of Facility */
	sectors: set of Sector := {};
	/* groupfacilities as a map of String to GroupFacility */
	group_sector: map seq of char to groupSector := {|->};


	cards: set of Card := {};
	cardUser: map Card to User := {|->};
	
	cardId: nat := 0;

operations

/*
public System : InstitutionName ==> System   
System(sys) == (
	name := sys;
	return self 
	);*/
 
 public System: seq of char ==> System
	System(sys) == (
		system := sys;
		return self;
	);
	
	public createCard: () ==> Card
	createCard() == (
		cardId := cardId + 1;
		let c: Card = new Card(cardId) in (
			cards := cards union {c};
			return c;
		);
	);
	
	
	public createUser : seq of char ==> User
	createUser(name) == (
		let user = mk_User(name) in (
			group_users := group_users munion { name |-> { user } };
			users := users union {user};
			return user;
		);
	)
	pre let u = mk_User(name) in u not in set users;
 
 /*
pure public getGroupUser: () ==> seq of Group_User
getGroupUser() == return group_users;
*/
/* getRules(sys)*/


functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end System



/* TODO 
addRuleSector(sector, regra)    
addRuleGroupSector(sectorGroup, regra)

addSector_toUser (setor, user)
addGroupsector_toUser (gourp, user)

addSector_toGroupUser (setor, user)
addGroupsector_toGroupUser (gourp, user)



*/
 