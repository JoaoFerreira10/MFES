class Rules
types
public DescriptionRule = seq of char;
public GroupSector = seq of char;
public GroupUser = seq of char;
values
-- TODO Define values here
instance variables
/*private description: DescriptionRule;
private sectors : seq of Sector :=[];
private rooms : seq of Room :=[];*/

private description: DescriptionRule;
public groupSector: GroupSector;
public groupUser: GroupUser;


operations

public Rules : DescriptionRule * GroupSector * GroupUser==> Rules
	Rules(desc, grsec, gruser) == (
		description := desc;
		groupSector := grsec;
		groupUser := gruser;
		return self;
	);

/*
public Rules : DescriptionRule ==> Rules  
Rules(ru) == (
	description := ru;
	
	return self 
	);*/
	
	/*
public RulesRoom : DescriptionRule * Room ==> Rules   
RulesRoom(ru, roo) == (
	description := ru;
	rooms := [roo]^rooms;
	return self 
	);*/
/*	public Rules : DescriptionRule * Sector ==> Rules    
Rules(ru, sec) == (
	description := ru;
	sectors := [sec]^sectors;
	return self 
	);*/
	/*
public addSector_to_rule : Sector ==> ()
addSector_to_rule(add) ==
sectors:= [add] ^ sectors
post sectors = [add]^sectors~;

public addRoom_to_rule : Room ==> ()
addRoom_to_rule(add) ==
rooms:= [add] ^ rooms
post rooms = [add]^rooms~;*/

functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Rules




/* 
> create s := new Sector("dei")
> print s.addRoom("i003")
()
> print s
Sector{#1, sector_name:="dei", room_name:=["i003"]}
> create r := new Rules("acesso ao i",s)
> print r
Rules{#2, description:="acesso ao i", sectors:=[Sector{#1, sector_name:="dei", room_name:=["i003"]}]} 

*/